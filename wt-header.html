<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/app-layout/app-drawer-layout/app-drawer-layout.html">
<link rel="import" href="bower_components/app-layout/app-drawer/app-drawer.html">
<link rel="import" href="bower_components/app-layout/app-header/app-header.html">
<link rel="import" href="bower_components/app-layout/app-header-layout/app-header-layout.html">
<link rel="import" href="bower_components/app-layout/app-toolbar/app-toolbar.html">
<link rel="import" href="bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="bower_components/iron-icons/iron-icons.html">
<link rel="import" href="bower_components/iron-image/iron-image.html">
<link rel="import" href="bower_components/iron-media-query/iron-media-query.html">
<link rel="import" href="bower_components/iron-selector/iron-selector.html">
<link rel="import" href="bower_components/iron-selector/iron-selectable.html">
<link rel="import" href="bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="bower_components/paper-item/paper-item.html">
<link rel="import" href="bower_components/paper-menu/paper-menu.html">
<link rel="import" href="bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="bower_components/paper-badge/paper-badge.html">
<link rel="import" href="bower_components/paper-material/paper-material.html">
<link rel="stylesheet" href="bower_components/w3c/w3.css">
<link rel="import" href="wt-tab.html">
<!--  
`wt-header`is a wrapper element that position an wt-tab and other element.when the viewport width is smaller then responsiveWidth,this element change to narrow layout.
   To use,insert  <wt-header> in the body:

     <wt-header id="wtheader" container="search" logourl="https://www.waiin.com/wp-content/uploads/2016/04/waiin@1x2-1.png">
      <wt-tabs>
      <wt-tab name="Home" action="/home.html" target="iframe1"></wt-tab>
      <wt-tab name="products" action="/products.html" target="iframe1"></wt-tab>
      <wt-tab name="Account" action="/Account.html" target="iframe1"></wt-tab>
      <wt-tab name="business" action="/business.html" target="iframe1"></wt-tab>
      <wt-tab name="about-us" action="/about-us.html" target="iframe1"></wt-tab>
    </wt-tabs>

    </wt-header>
    




### Styling
Custom property              | Description                                | Default
-----------------------------|------------------------------              |-----------------------
`--app-primary-color         |  background-color  of the app-toolbar      |   #cc0046
--menu-text-color`           |  font color                                |#000000
--menu-selection-color       |   Color for the selection bar              |  powderblue
--app-drawer-color           |     background-Color for drawer            |	midnightblue
--container-color            |	The background color of the card          |	#000000




@demo demo/index.html



-->

<dom-module id="wt-header">
  <template>
    <style is="custom-style">
      :host {
        --app-primary-color: #cc0046;
        --menu-text-color: black;
        --container-color: black;
        --app-drawer-color: midnightblue;
        --menu-selection-color: powderblue;
        display: block;
      }
      /*mixin css*/
      
      :root {
        --background-theme: {
          color: var(--menu-text-color);
          background-color: var(--app-primary-color);
        }
        --paper-icon-btn: {
          position: absolute;
          right: 0;
          width: 80px;
          font-size: 14px;
          color: var(--container-color);
          line-height: 42px;
          border-width: 0;
          -webkit-border-radius: 0px 5px 5px 0px;
          -moz-border-radius: 0px 5px 5px 0px;
          border-radius: 0px 5px 5px 0px;
        }
      }
      
      app-toolbar {
        @apply --background-theme;
      }
      
      .main-header {
        @apply --background-theme;
      }
      
      paper-tabs {
        max-width: 640px;
        --paper-tabs-selection-bar-color: #800000;
           padding-left: 100px;
      }
      
      paper-tab {
        text-transform: uppercase;
        -webkit-text-fill-color: var(--menu-text-color);
      }
      
      paper-icon-button.blue {
        @apply --paper-icon-btn;
        top: 10px;
        height: 42px;
      }
      
      paper-icon-button.blue1 {
        @apply --paper-icon-btn;
        top: 3px;
        height: 40px;
      }
      
      [hidden] {
        display: none !important;
      }
      
      .iron-selected {
        background-color: var(--menu-selection-color);
      }
      
      #drawermwnu {
        display: list-item;
        
      }
      
      .w3-light-grey {
        color: var(--menu-text-color);
        background-color: var(--app-drawer-color);
      }
      
      .w3-sidenav a:hover {
        background-color: transparent !important;
      }
    
    </style>

<!-- force-narrow prevents the drawer from ever being displayed
       in persistent mode -->
<app-drawer-layout force-narrow>

  <app-drawer id="drawer">
    <iron-selector id="drawermenu" class="w3-sidenav w3-light-grey" attr-for-selected="name" selected="{{selected}}">
    </iron-selector>
  </app-drawer>

  <app-toolbar>
    <!-- drawer toggle button -->
    <paper-icon-button class="menu-button" icon="menu" drawer-toggle hidden$="{{wideLayout}}"></paper-icon-button>
    <paper-icon-button icon="{{container}}" class="blue1"></paper-icon-button>
  </app-toolbar>

  <app-header-layout>
    <app-header class="main-header" selected="{{selected}}" attr-for-selected="name">
      <app-toolbar class="tabs-bar" hidden$="{{!wideLayout}}">
        <!-- Nav on desktop: tabs -->
        <iron-image height="{{height}}" width="{{width}}" sizing="contain" src="{{logourl}}"></iron-image>
        <paper-tabs selected="{{selected}}" attr-for-selected="name" bottom-item>
          <iron-selector id="headermenu" attr-for-selected="name" selected="{{selected}}" scrollable>
          </iron-selector>
        </paper-tabs>
        <paper-icon-button class="blue" icon="{{container}}"></paper-icon-button>

      </app-toolbar>
    </app-header>
  </app-header-layout>

</app-drawer-layout>

<!--resizing the window-->
<iron-media-query query="{{responsivness}}" query-matches="{{wideLayout}}"></iron-media-query>

</template>

<script>
    Polymer({
      is: 'wt-header',

      properties: {
        /*Gets or sets the selected element. The default is to use the index of the Home.*/
        selected: {
          type: String,
          Value: 'Home'

        },
        /*The Boolean return value of the media query.*/
        wideLayout: {
          type: Boolean,
          value: false,
          observer: 'onLayoutChange',
        },
        /*It is used to set logourl as per demand.User has to  only bind value to logourl property.
         */
        logoUrl: {
          type: String,
          value: 'https://www.waiin.com/wp-content/uploads/2016/04/waiin@1x2-1.png'
        },
        /*Specifies the icon name or index in the set of icons available in the icon's icon set. */
        container: {
          type: String,
          value: 'search'
        },
        /*Can be used to set the Width of logoimage (e.g. via binding); size may also be set via CSS.*/
        width: {
          type: Number,
          value: 160
        },
        /*Can be used to set the height of logoimage (e.g. via binding); size may also be set via CSS.*/
        height: {
          type: Number,
          value: 45
        },
        /*The CSS media query to evaluate.*/
        responsivness: {
          type: String

        },
      },
      //add or remove drawer for navigation on change of screen size.
      onLayoutChange: function (wide) {
        var drawer = this.$.drawer;
        if (wide && drawer.opened) {
          drawer.opened = false;
          drawer.closed = false;
        }
      },

      attached: function () {

        var vdrawermenu = this.$.drawermenu;
        var vheadermenu = this.$.headermenu;
        var effectiveChildren = Polymer.dom(this).getEffectiveChildNodes();
        effectiveChildren.forEach(function (entry1) {
          if (entry1.nodeName == "WT-TABS")
            for (var i = 0; i < entry1.children.length; i++) {
              var tbc = entry1.children[i];
              if (tbc.id == "tabsContainer") {
                for (var j = 0; j < tbc.children.length; j++) {
                  var tb = tbc.children[j];
                  for (var k = 0; k < tb.children.length; k++) {
                    var wtb = tb.children[k];
                    if (wtb.tagName == "WT-TAB") {
                      var child = document.createElement("paper-tab")
                      child.setAttribute("name", wtb.getAttribute("name"))
                      child.setAttribute("class", "style-scope wt-header")
                      var childLink = document.createElement("a")
                      childLink.setAttribute("href", wtb.getAttribute("action"))
                      childLink.setAttribute("target", wtb.getAttribute("target"))
                      childLink.setAttribute("drawer-toggle", "")
                      childLink.innerText = wtb.getAttribute("name");
                      child.appendChild(childLink)
                      vdrawermenu.appendChild(child);
                      vheadermenu.appendChild(child.cloneNode(true))
                    }
                  }
                }
              }
            }
        });
      }
    });
  </script>
</dom-module>

<dom-module id="wt-tabs">
  <style>
    :host {
      @apply(--layout);
      @apply(--layout-center);
      height: 48px;
      font-size: 14px;
      font-weight: 500;
      overflow: hidden;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
      -webkit-tap-highlight-color: transparent;
      @apply(--paper-tabs);
    }
    
    :host-context([dir=rtl]) {
      @apply(--layout-horizontal-reverse);
    }
    
    #tabsContainer {
      position: relative;
      height: 100%;
      white-space: nowrap;
      overflow: hidden;
      @apply(--layout-flex-auto);
      @apply(--paper-tabs-container);
    }
    
    #tabsContent {
      height: 100%;
      -moz-flex-basis: auto;
      -ms-flex-basis: auto;
      flex-basis: auto;
      @apply(--paper-tabs-content);
    }
    
    #tabsContent.scrollable {
      position: absolute;
      white-space: nowrap;
    }
    
    #tabsContent:not(.scrollable),
    #tabsContent.scrollable.fit-container {
      @apply(--layout-horizontal);
    }
    
    #tabsContent.scrollable.fit-container {
      min-width: 100%;
    }
    
    #tabsContent.scrollable.fit-container >::content > * {
      /* IE - prevent tabs from compressing when they should scroll. */
      -ms-flex: 1 0 auto;
      -webkit-flex: 1 0 auto;
      flex: 1 0 auto;
    }
    
    .app-drawer-0[opened] > #contentContainer.app-drawer {
      background-color: darkred;
    }
    
    .hidden {
      display: none;
    }
    
    .not-visible {
      opacity: 0;
      cursor: default;
    }
    
    paper-icon-button {
      width: 48px;
      height: 48px;
      padding: 12px;
      margin: 0 4px;
    }
    
    #selectionBar {
      position: absolute;
      height: 2px;
      bottom: 0;
      left: 0;
      right: 0;
      /*background-color: var(--paper-tabs-selection-bar-color, --paper-yellow-a100);*/
      -webkit-transform: scale(0);
      transform: scale(0);
      -webkit-transform-origin: left center;
      transform-origin: left center;
      transition: -webkit-transform;
      transition: transform;
      @apply(--paper-tabs-selection-bar);
    }
    
    #selectionBar.align-bottom {
      top: 0;
      bottom: auto;
    }
    
    #selectionBar.expand {
      transition-duration: 0.15s;
      transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
    }
    
    #selectionBar.contract {
      transition-duration: 0.18s;
      transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
    }
    
    #tabsContent >::content > *:not(#selectionBar) {
      height: 100%;
    }
    
    .iron-selected {
      background: #eee;
    }
  </style>

<template>

  <div id="tabsContainer" on-track="_scroll" on-down="_down">
    <div id="tabsContent" class$="[[_computeTabsContentClass(scrollable, fitContainer)]]">
      <div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]" on-transitionend="_onBarTransitionEnd"></div>
      <content select="*"></content>
    </div>
  </div>

  <iron-media-query query="min-width: 600px" query-matches="{{wideLayout}}"></iron-media-query>

</template>

<script>
    Polymer({
      is: 'wt-tabs',
      behaviors: [
        Polymer.IronResizableBehavior,
        Polymer.IronMenubarBehavior,
        Polymer.IronSelectableBehavior
      ],

      properties: {
        /**
         * If true, ink ripple effect is disabled. When this property is changed,
         * all descendant `<wt-tab>` elements have their `noink` property
         * changed to the new value as well.
         */
        noink: {
          type: Boolean,
          value: false,
          observer: '_noinkChanged'
        },

        /**
         * If true, the bottom bar to indicate the selected tab will not be shown.
         */
        noBar: {
          type: Boolean,
          value: false
        },

        /**
         * If true, the slide effect for the bottom bar is disabled.
         */
        noSlide: {
          type: Boolean,
          value: false
        },

        /**
         * If true, tabs are scrollable and the tab width is based on the label width.
         */
        scrollable: {
          type: Boolean,
          value: false
        },

        /**
         * If true, tabs expand to fit their container. This currently only applies when
         * scrollable is true.
         */
        fitContainer: {
          type: Boolean,
          value: false
        },

        /**
         * If true, dragging on the tabs to scroll is disabled.
         */
        disableDrag: {
          type: Boolean,
          value: false
        },

        /**
         * If true, scroll buttons (left/right arrow) will be hidden for scrollable tabs.
         */
        hideScrollButtons: {
          type: Boolean,
          value: false
        },

        /**
         * If true, the tabs are aligned to bottom (the selection bar appears at the top).
         */
        alignBottom: {
          type: Boolean,
          value: false
        },

        selected: {
          type: String,
          value: 'Home'
        },

        selectable: {
          type: String,
          value: 'wt-tab'
        },

        /**
         * If true, tabs are automatically selected when focused using the
         * keyboard.
         */
        autoselect: {
          type: Boolean,
          value: false
        },

        /**
         * The delay (in milliseconds) between when the user stops interacting
         * with the tabs through the keyboard and when the focused item is
         * automatically selected (if `autoselect` is true).
         */
        autoselectDelay: {
          type: Number,
          value: 0
        },

        _step: {
          type: Number,
          value: 10
        },

        _holdDelay: {
          type: Number,
          value: 1
        },

        _leftHidden: {
          type: Boolean,
          value: false
        },

        _rightHidden: {
          type: Boolean,
          value: false
        },

        _previousTab: {
          type: Object
        }
      },

      hostAttributes: {
        role: 'tablist'
      },

      listeners: {
        'iron-resize': '_onTabSizingChanged',
        'iron-items-changed': '_onTabSizingChanged',
        'iron-select': '_onIronSelect',
        'iron-deselect': '_onIronDeselect'
      },

      keyBindings: {
        'left:keyup right:keyup': '_onArrowKeyup'
      },

      created: function () {
        this._holdJob = null;
        this._pendingActivationItem = undefined;
        this._pendingActivationTimeout = undefined;
        this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
        this.addEventListener('blur', this._onBlurCapture.bind(this), true);
      },

      ready: function () {
        this.setScrollDirection('y', this.$.tabsContainer);
      },

      detached: function () {
        this._cancelPendingActivation();
      },

      _noinkChanged: function (noink) {
        var childTabs = Polymer.dom(this).querySelectorAll('wt-tab');
        childTabs.forEach(noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
      },

      _setNoinkAttribute: function (element) {
        element.setAttribute('noink', '');
      },

      _removeNoinkAttribute: function (element) {
        element.removeAttribute('noink');
      },

      _computeScrollButtonClass: function (hideThisButton, scrollable, hideScrollButtons) {
        if (!scrollable || hideScrollButtons) {
          return 'hidden';
        }

        if (hideThisButton) {
          return 'not-visible';
        }

        return '';
      },

      _computeTabsContentClass: function (scrollable, fitContainer) {
        return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') : ' fit-container';
      },

      _computeSelectionBarClass: function (noBar, alignBottom) {
        if (noBar) {
          return 'hidden';
        } else if (alignBottom) {
          return 'align-bottom';
        }

        return '';
      },

      // TODO(cdata): Add `track` response back in when gesture lands.

      _onTabSizingChanged: function () {
        this.debounce('_onTabSizingChanged', function () {
          this._scroll();
          this._tabChanged(this.selectedItem);
        }, 10);
      },

      _onIronSelect: function (event) {
        this._tabChanged(event.detail.item, this._previousTab);
        this._previousTab = event.detail.item;
        this.cancelDebouncer('tab-changed');
      },

      _onIronDeselect: function (event) {
        this.debounce('tab-changed', function () {
          this._tabChanged(null, this._previousTab);
          this._previousTab = null;
          // See polymer/polymer#1305
        }, 1);
      },

      _activateHandler: function () {
        // Cancel item activations scheduled by keyboard events when any other
        // action causes an item to be activated (e.g. clicks).
        this._cancelPendingActivation();

        Polymer.IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
      },

      /**
       * Activates an item after a delay (in milliseconds).
       */
      _scheduleActivation: function (item, delay) {
        this._pendingActivationItem = item;
        this._pendingActivationTimeout = this.async(
          this._bindDelayedActivationHandler, delay);
      },

      wideLayout: {
        type: Boolean,
        value: false,
        observer: 'onLayoutChange',
      },
      /**
       * Activates the last item given to `_scheduleActivation`.
       */
      _delayedActivationHandler: function () {
        var item = this._pendingActivationItem;
        this._pendingActivationItem = undefined;
        this._pendingActivationTimeout = undefined;
        item.fire(this.activateEvent, null, {
          bubbles: true,
          cancelable: true
        });
      },

      /**
       * Cancels a previously scheduled item activation made with
       * `_scheduleActivation`.
       */
      _cancelPendingActivation: function () {
        if (this._pendingActivationTimeout !== undefined) {
          this.cancelAsync(this._pendingActivationTimeout);
          this._pendingActivationItem = undefined;
          this._pendingActivationTimeout = undefined;
        }
      },

      _onArrowKeyup: function (event) {
        if (this.autoselect) {
          this._scheduleActivation(this.focusedItem, this.autoselectDelay);
        }
      },

      _onBlurCapture: function (event) {
        // Cancel a scheduled item activation (if any) when that item is
        // blurred.
        if (event.target === this._pendingActivationItem) {
          this._cancelPendingActivation();
        }
      },

      get _tabContainerScrollSize() {
        return Math.max(
          0,
          this.$.tabsContainer.scrollWidth -
          this.$.tabsContainer.offsetWidth
        );
      },

      _scroll: function (e, detail) {
        if (!this.scrollable) {
          return;
        }

        var ddx = (detail && -detail.ddx) || 0;
        this._affectScroll(ddx);
      },

      _down: function (e) {
        // go one beat async to defeat IronMenuBehavior
        // autorefocus-on-no-selection timeout
        this.async(function () {
          if (this._defaultFocusAsync) {
            this.cancelAsync(this._defaultFocusAsync);
            this._defaultFocusAsync = null;
          }
        }, 1);
      },

      _affectScroll: function (dx) {
        this.$.tabsContainer.scrollLeft += dx;

        var scrollLeft = this.$.tabsContainer.scrollLeft;

        this._leftHidden = scrollLeft === 0;
        this._rightHidden = scrollLeft === this._tabContainerScrollSize;
      },

      _onLeftScrollButtonDown: function () {
        this._scrollToLeft();
        this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
      },

      _onRightScrollButtonDown: function () {
        this._scrollToRight();
        this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
      },

      _onScrollButtonUp: function () {
        clearInterval(this._holdJob);
        this._holdJob = null;
      },

      _scrollToLeft: function () {
        this._affectScroll(-this._step);
      },

      _scrollToRight: function () {
        this._affectScroll(this._step);
      },

      _tabChanged: function (tab, old) {
        if (!tab) {
          // Remove the bar without animation.
          this.$.selectionBar.classList.remove('expand');
          this.$.selectionBar.classList.remove('contract');
          this._positionBar(0, 0);
          return;
        }

        var r = this.$.tabsContent.getBoundingClientRect();
        var w = r.width;
        var tabRect = tab.getBoundingClientRect();
        var tabOffsetLeft = tabRect.left - r.left;

        this._pos = {
          width: this._calcPercent(tabRect.width, w),
          left: this._calcPercent(tabOffsetLeft, w)
        };

        if (this.noSlide || old == null) {
          // Position the bar without animation.
          this.$.selectionBar.classList.remove('expand');
          this.$.selectionBar.classList.remove('contract');
          this._positionBar(this._pos.width, this._pos.left);
          return;
        }

        var oldRect = old.getBoundingClientRect();
        var oldIndex = this.items.indexOf(old);
        var index = this.items.indexOf(tab);
        var m = 5;

        // bar animation: expand
        this.$.selectionBar.classList.add('expand');

        var moveRight = oldIndex < index;
        var isRTL = this._isRTL;
        if (isRTL) {
          moveRight = !moveRight;
        }

        if (moveRight) {
          this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m,
            this._left);
        } else {
          this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m,
            this._calcPercent(tabOffsetLeft, w) + m);
        }

        if (this.scrollable) {
          this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
        }
      },

      _scrollToSelectedIfNeeded: function (tabWidth, tabOffsetLeft) {
        var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
        if (l < 0) {
          this.$.tabsContainer.scrollLeft += l;
        } else {
          l += (tabWidth - this.$.tabsContainer.offsetWidth);
          if (l > 0) {
            this.$.tabsContainer.scrollLeft += l;
          }
        }
      },

      _calcPercent: function (w, w0) {
        return 100 * w / w0;
      },

      _positionBar: function (width, left) {
        width = width || 0;
        left = left || 0;

        this._width = width;
        this._left = left;
        this.transform(
          'translateX(' + left + '%) scaleX(' + (width / 100) + ')',
          this.$.selectionBar);
      },

      _onBarTransitionEnd: function (e) {
        var cl = this.$.selectionBar.classList;
        // bar animation: expand -> contract
        if (cl.contains('expand')) {
          cl.remove('expand');
          cl.add('contract');
          this._positionBar(this._pos.width, this._pos.left);
          // bar animation done
        } else if (cl.contains('contract')) {
          cl.remove('contract');
        }
      },
      //add or remove drawer for navigation on change of screen size.
      onLayoutChange: function (wide) {
        var drawer = this.$.drawer;
        if (wide && drawer.opened) {
          drawer.opened = false;
        }
      }
    });
  </script>
</dom-module>